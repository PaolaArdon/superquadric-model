<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="yarpmanifest.xsl"?>

<module>
  <name>superquadric-detection</name>
  <doxygen-group></doxygen-group>
  <description>Framework for object detecting and modeling.</description>
  <copypolicy>Released under the terms of the GNU GPL v2.0</copypolicy>
  <version>1.0</version>
  
  <description-long>
    This module allows object detection and modelling. You can run it in different modes:
    - _real-time_, when the object is detected and modeled constantly;
    - _one-shot_ mode. In this case it can compute the superquadric model from a .off _file_, containing the point cloud of interest or _on-line_, receiving the point cloud from the cameras.


    To correctly launch the module, do the following:
    - Put an <b>object</b> in the robot's sight (for example, on a table in front of it) and make sure that the <b>eye vergence</b> is equal to that value used during _SFM_ calibration.
    - Launch <b>IOL</b> application and make sure that _SFM_ is giving a good disparity map (otherwise calibrate it thorugh the proper rpc port).
    - Launch <b>superquadric-detection</b> application (_superquadric-detection module and two _yarpviews_), through the _yarpmanager_ and make all the connections.
    - Open the rpc port _/superquadric-detection/rpc_ to play with the application. A possible rpc command sequence if the following:
        - <b>set_object_name ball</b> (e.g.), if we want to model the object "ball". If the object is known by IOL, the superquadric will be computed, otherwise, the application will wait to receive  the object or otherwise, it will wait for another object name.
        - <b> get_superq ball </b> returns the 11 parameters of the reconstructed superquadric.
    The other possible rpc commands are described in the link below.
    The result of the superquadric reconstruction is visible also on the yarpview showing the image caming from the left camera. Here, you can find a visualization of the superquadric, overlapped on the object.

  </description-long>

  <arguments>
    <param default="superquadric-detection" desc="Select the current context.">context</param>
    <param default="config.ini" desc="Configuration file name.">from</param>
    <param default="left" desc="Eye used for projection of the 3D points on the superquadric surface to the 2D pixels">eye</param>
    <param default="3" desc="Downsampling value for point cloud acquisition: if you increase it, the retrieved point cloud will be more sparse.">downsampling</param>
    <param default="0.00001" desc="IPOPT objective function tollerance. The smaller is the value, the more accurate is the final solution.">tol</param>
    <param default="0" desc="IPOPT acceptable iter.">acceptable_iter</param>
    <param default="max numeric limit" desc="IPOPT maximum iteration.">max_iter</param>
    <param default="0.6" desc="Maximum cpu time for algorithm execution.">max_cpu_time</param> 
    <param default="adaptive" desc="IPOPT mu strategy.">mu_strategy</param> 
    <param default="none" desc="IPOPT nlp_scaling_method.">nlp_scaling_method</param>    
    <param default="0.0002" desc="Radius value for filtering.">radius</param> 
    <param default="80" desc="Threshold value for filtering.">nnThreshold</param> 
    <param default="false" desc="Variable to decide to filter points or not">filter_on</param>  
    <param default="80" desc="Points used by the optimization algorithm to reconstruct the superquadric function.">optimizer_points</param> 
    <param default="1" desc="Boolean variable to switch between online and offline mode.">online</param> 
    <param default="" desc="File containing the point cloud to be modeled.">pointCloudFile</param> 
  </arguments>
 
  <authors>
    <author email="giulia.vezzani@iit.it"> Giulia Vezzani </author>
  </authors>

  <data>
  <input>
      <type>std::vector of Point</type>
      <port carrier="tcp">/superquadric-detection/contour:i</port>
      <description>
        receive xy-coordinates of the pixel clicked on the image from the camera.
      </description>
  </input>
  <input>
      <type>yarp::sig::ImageOfPixelRgb</type>
      <port carrier="tcp">/superquadric-detection/img:i</port>
      <description>
        receive the image from the left camera.
      </description>
  </input>
    <output>
      <type>yarp::sig::ImageOfPixelMono</type>
      <port carrier="tcp">/superquadric-detection/disp:o</port>
      <description>
        send disparity map with the overlapped selected blob.
      </description>
    </output>

  </data>
 
  <services>
    <server>
      <type>superquadricDetection_IDL</type>
      <idl>idl.thrift</idl>
      <port>/superquadric-detection/rpc</port>
      <description>service port</description>
    </server>
  </services>
 
</module>

